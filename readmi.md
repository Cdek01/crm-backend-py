pip install -r requirements.txt
venv\Scripts\activate.bat
http://89.111.169.47:8005/docs

Запустить Redis (если еще не запущен):
Generated bash
docker run -d -p 6379:6379 redis
Use code with caution.
Bash
Запустить воркер Celery: (в корне проекта, с активным venv)
Generated bash
celery -A celery_worker.celery_app worker --loglevel=info
Use code with caution.
Bash
Этот терминал будет показывать логи выполнения фоновых задач.
Запустить веб-сервер FastAPI: (в корне проекта, с активным venv)
Generated bash
uvicorn main:app --reload



Актуальные эндпоинты API
На данный момент в вашем API реализована базовая аутентификация и один защищенный маршрут. Вот они:
1. Регистрация нового пользователя
Метод: POST
URL: /api/auth/register
Описание: Создает нового пользователя в системе.
Тело запроса (Request Body): JSON-объект со следующими полями:
Generated json
{
  "email": "user@example.com",
  "password": "some_strong_password",
  "full_name": "John Doe"
}
Use code with caution.
Json
Успешный ответ (Response): 201 Created
Тело ответа: JSON-объект с данными созданного пользователя (без пароля).
Generated json
{
  "id": 1,
  "email": "user@example.com",
  "full_name": "John Doe"
}
Use code with caution.
Json
Возможные ошибки:
400 Bad Request: если пользователь с таким email уже существует или данные невалидны.
2. Вход в систему (получение токена)
Метод: POST
URL: /api/auth/token
Описание: Проверяет учетные данные пользователя и в случае успеха возвращает JWT-токен доступа.
Тело запроса (Request Body): Данные формы (form-data), не JSON. В интерактивной документации FastAPI (/docs) это будут два отдельных поля.
username: email пользователя
password: пароль пользователя
Успешный ответ (Response): 200 OK
Тело ответа: JSON-объект с токеном.
Generated json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}
Use code with caution.
Json
Возможные ошибки:
401 Unauthorized: если email или пароль неверны.
3. Получение данных о себе (защищенный эндпоинт)
Метод: GET
URL: /api/users/me
Описание: Возвращает информацию о текущем авторизованном пользователе. Требует авторизации.
Авторизация: Необходимо передать заголовок Authorization: Bearer <ваш_токен>.
Тело запроса: Нет.
Успешный ответ (Response): 200 OK
Тело ответа: JSON-объект с данными текущего пользователя.
Generated json
{
  "id": 1,
  "email": "user@example.com",
  "full_name": "John Doe"
}
Use code with caution.
Json
Возможные ошибки:
401 Unauthorized: если токен не предоставлен, недействителен или истек.
4. Корневой эндпоинт
Метод: GET
URL: /
Описание: Простой эндпоинт для проверки, что сервер запущен.
Успешный ответ (Response): 200 OK
Тело ответа: {"message": "Welcome to CRM API"}


http://127.0.0.1:8000/docs












Они сгруппированы так же, как вы увидите их в интерактивной документации FastAPI по адресу http://127.0.0.1:8000/docs.
Сводная таблица эндпоинтов
Метод	URL	Описание	Требует авторизации?
POST	/api/auth/register	Регистрация нового пользователя	Нет
POST	/api/auth/token	Вход в систему и получение JWT токена	Нет
GET	/api/users/me	Получение данных о текущем пользователе	Да
POST	/api/leads/	Создание нового лида	Да
GET	/api/leads/	Получение списка всех лидов	Да
GET	/api/leads/{lead_id}	Получение одного лида по его ID	Да
PUT	/api/leads/{lead_id}	Обновление информации о лиде	Да
DELETE	/api/leads/{lead_id}	Удаление лида	Да
GET	/	Корневой эндпоинт для проверки работы сервера	Нет
Подробное описание по группам (tags)
Группа: auth (Аутентификация)
Эти эндпоинты отвечают за управление доступом.
POST /api/auth/register
Назначение: Создает нового пользователя.
Запрос: JSON с email, password, full_name.
Авторизация: Не требуется.
POST /api/auth/token
Назначение: Аутентифицирует пользователя и выдает access_token.
Запрос: form-data с полями username (ваш email) и password.
Авторизация: Не требуется.
Группа: users (Пользователи)
Эндпоинты, связанные с данными пользователей.
GET /api/users/me
Назначение: Позволяет авторизованному пользователю получить информацию о себе.
Запрос: Нет тела запроса.
Авторизация: Требуется. Необходимо передать заголовок Authorization: Bearer <токен>.
Группа: leads (Лиды)
Это ваш первый полноценный CRUD-модуль. Все эндпоинты в этой группе защищены и требуют авторизации.
POST /api/leads/
Назначение: Создает новый лид. Ответственным автоматически назначается текущий пользователь.
Запрос: JSON с данными для нового лида (согласно вашей Pydantic-схеме LeadCreate).
GET /api/leads/
Назначение: Возвращает список всех лидов. Можно использовать пагинацию (?skip=0&limit=10).
GET /api/leads/{lead_id}
Назначение: Возвращает детальную информацию о конкретном лиде по его id.
PUT /api/leads/{lead_id}
Назначение: Обновляет данные существующего лида.
Запрос: JSON с полями, которые нужно обновить.
DELETE /api/leads/{lead_id}
Назначение: Удаляет лид из базы данных.









Итоговые изменения в проекте:
1. Внедрение Multi-tenancy (Изоляция данных клиентов)
Цель: Сделать так, чтобы данные одной компании-клиента были отделены от данных другой.
Новая модель Tenant (db/models.py):
Создали таблицу tenants для хранения информации о компаниях-клиентах (их ID, имя и т.д.).
Добавление tenant_id во все модели:
Во все ключевые модели (User, Lead, LegalEntity, Individual, EntityType) добавили поле tenant_id, которое является внешним ключом к таблице tenants.
Это гарантирует, что каждая запись в базе данных теперь "знает", какому клиенту она принадлежит.
Изменение логики регистрации (api/endpoints/auth.py):
Эндпоинт /register теперь не просто создает пользователя, а выполняет целый бизнес-процесс:
Создает новую запись в tenants (нового клиента).
Создает новую запись в users.
Связывает нового пользователя с только что созданным клиентом через tenant_id.
Изменение всех сервисов и эндпоинтов:
Все функции, которые получают или изменяют данные (например, get_all_leads, create_entity_type), теперь принимают current_user.
Внутри этих функций каждый запрос к базе данных теперь содержит обязательное условие WHERE tenant_id = current_user.tenant_id. Это и есть главный механизм изоляции данных.
2. Внедрение конструктора таблиц (Модель EAV)
Цель: Дать пользователям возможность создавать свои собственные таблицы с произвольными полями.
Новые EAV-модели (db/models.py):
EntityType: Описывает "таблицу" (например, "Проекты").
Attribute: Описывает "колонку" (например, "Бюджет" с типом "float").
Entity: Представляет "строку" в пользовательской таблице.
AttributeValue: Хранит конкретное значение для одной ячейки.
Новые Pydantic-схемы (schemas/eav.py):
Создали схемы для валидации данных при создании и отображении EntityType и Attribute.
Новый сервисный слой (services/eav_service.py):
Написали сложную логику для работы с EAV-структурой:
Создание/чтение метаданных (типов и атрибутов).
"Пивотирование" (pivoting) данных: преобразование вертикальной EAV-структуры в привычные горизонтальные JSON-объекты для фронтенда и обратно.
Новые API-эндпоинты:
/api/meta: Группа эндпоинтов для управления метаданными (создание "таблиц" и "колонок").
/api/data: Группа эндпоинтов для CRUD-операций с данными внутри этих пользовательских таблиц.
3. Настройка и исправление окружения
Цель: Обеспечить корректную работу проекта и его развитие.
Инициализация и настройка Alembic:
Создали alembic.ini и настроили alembic/env.py, чтобы инструмент миграций "видел" наши модели и базу данных.
Научились использовать команды alembic revision --autogenerate и alembic upgrade head для синхронизации кода моделей с реальной схемой базы данных.
Отладка и исправление ошибок:
Исправили множество ошибок, от простых (NameError) до сложных (AttributeError, IntegrityError), анализируя логи и трассировку.
Добавили недостающие relationship в моделях SQLAlchemy для корректной работы joinedload.
Улучшение тестового скрипта (zapr.py):
Сделали генерируемые данные (имя пользователя) уникальными для каждого запуска, чтобы избежать конфликтов UNIQUE constraint и сделать тесты повторяемыми.