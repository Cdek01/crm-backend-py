# """Add cascade delete to attribute_values
#
# Revision ID: e351d719425c
# Revises: 590f28caa906
# Create Date: 2025-07-30 12:28:05.323708
#
# """
# from typing import Sequence, Union
#
# from alembic import op
# import sqlalchemy as sa
#
#
# # revision identifiers, used by Alembic.
# revision: str = 'e351d719425c'
# down_revision: Union[str, None] = '590f28caa906'
# branch_labels: Union[str, Sequence[str], None] = None
# depends_on: Union[str, Sequence[str], None] = None
#
#
# def upgrade() -> None:
#     # ### commands auto generated by Alembic - please adjust! ###
#     op.drop_constraint(None, 'attribute_values', type_='foreignkey')
#     op.create_foreign_key(None, 'attribute_values', 'attributes', ['attribute_id'], ['id'], ondelete='CASCADE')
#     # ### end Alembic commands ###
#
#
# def downgrade() -> None:
#     # ### commands auto generated by Alembic - please adjust! ###
#     op.drop_constraint(None, 'attribute_values', type_='foreignkey')
#     op.create_foreign_key(None, 'attribute_values', 'attributes', ['attribute_id'], ['id'])
#     # ### end Alembic commands ###


# e351d719425c_add_cascade_delete_to_attribute_values.py

"""Add cascade delete to attribute_values

Revision ID: e351d719425c
Revises: 590f28caa906
Create Date: ...

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'e351d719425c'
down_revision = '590f28caa906'  # Убедитесь, что ID предыдущей миграции здесь правильный
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Используем batch_alter_table для совместимости с SQLite
    with op.batch_alter_table('attribute_values', schema=None) as batch_op:
        # Сначала удаляем старый внешний ключ
        # ВАЖНО: нужно указать имя ограничения. Его можно найти в старых миграциях или в .db файле
        # Если имя неизвестно, Alembic может его не найти. Часто оно генерируется автоматически.
        # Попробуем без имени, но если не сработает, нужно будет его найти.
        # Для SQLite часто проще пересоздать ключ, чем угадывать имя.
        # Мы просто создадим новый, а batch mode разберется.

        # Пересоздаем внешний ключ с опцией каскадного удаления
        batch_op.create_foreign_key(
            'fk_attribute_values_attribute_id_attributes',  # Даем ограничению осмысленное имя
            'attributes', ['attribute_id'], ['id'],
            ondelete='CASCADE'
        )


def downgrade() -> None:
    # Откатываем изменения в batch-режиме
    with op.batch_alter_table('attribute_values', schema=None) as batch_op:
        # Удаляем созданный нами ключ
        batch_op.drop_constraint('fk_attribute_values_attribute_id_attributes', type_='foreignkey')

        # Можно воссоздать старый ключ без каскадного удаления, если нужно
        # batch_op.create_foreign_key(
        #     'fk_attribute_values_attribute_id_attributes_old', # Другое имя
        #     'attributes', ['attribute_id'], ['id']
        # )





# e351d719425c_add_cascade_delete_to_attribute_values.py (Упрощенная версия)

def upgrade() -> None:
    with op.batch_alter_table('attribute_values', schema=None) as batch_op:
        # Batch mode пересоздаст таблицу. Нам нужно просто указать,
        # какие изменения мы хотим внести в структуру.
        # В данном случае, мы не удаляем старый ключ, а просто говорим
        # "создай мне новый ключ с каскадом". Batch mode сам разберется.
        batch_op.create_foreign_key(
            'fk_attribute_values_attribute_id',  # Имя ограничения
            'attributes',
            ['attribute_id'],
            ['id'],
            ondelete='CASCADE'
        )


def downgrade() -> None:
    with op.batch_alter_table('attribute_values', schema=None) as batch_op:
        # Просто удаляем ограничение, которое создали в upgrade
        batch_op.drop_constraint('fk_attribute_values_attribute_id', type_='foreignkey')